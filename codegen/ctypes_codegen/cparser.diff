pcl-cvs: descending directory 
Index: cparser.py
===================================================================
RCS file: /cvsroot/ctypes/ctypes/codegen/ctypes_codegen/cparser.py,v
retrieving revision 1.2
diff -u -r1.2 cparser.py
--- cparser.py	8 Jun 2006 19:11:41 -0000	1.2
+++ cparser.py	14 Jun 2006 13:18:04 -0000
@@ -1,10 +1,9 @@
 import sys, os, re, tempfile
-from cparser_config import C_KEYWORDS, EXCLUDED, EXCLUDED_RE
+##from cparser_config import C_KEYWORDS, EXCLUDED, EXCLUDED_RE
+C_KEYWORDS = EXCLUDED = EXCLUDED_RE = []
 import gccxmlparser, typedesc
-try:
-    import subprocess
-except ImportError:
-    subprocess = None
+import subprocess # the subprocess is required
+
 try:
     set
 except NameError:
@@ -28,18 +27,6 @@
     if loc:
         os.environ["PATH"] = loc
 
-def find_gccxml():
-    # find gccxml on $PATH
-    if sys.platform == "win32":
-        GCCXML = "gccxml.exe"
-    else:
-        GCCXML = "gccxml"
-    for directory in os.environ["PATH"].split(os.pathsep):
-        what = os.path.join(directory, GCCXML)
-        if os.path.isfile(what):
-            return what
-    return None
-        
 class CompilerError(Exception):
     pass
 
@@ -59,15 +46,17 @@
         self.excluded = set()
         self.excluded.update(EXCLUDED)
         self.excluded.update(self.options.excluded_symbols)
+        try:
+            data = open("cparser.cfg", "U").read()
+        except IOError:
+            pass
+        else:
+            self.excluded.update(data.splitlines())
+            
 
         self.excluded_re = set()
         self.excluded_re.update(EXCLUDED_RE)
         self.excluded_re.update(self.options.excluded_symbols_re)
-        if subprocess is None:
-            if not find_gccxml():
-                import errno
-                raise OSError, (errno.ENOENT, "gccxml not found")
-
 
     def create_source_file(self, lines, ext=".cpp"):
         "Create a temporary file, write lines to it, and return the filename"
@@ -89,15 +78,10 @@
                 args.extend(self.options.flags)
             if self.options.verbose:
                 print >> sys.stderr, "running:", " ".join(args)
-            if subprocess:
-                proc = subprocess.Popen(args,
-                                        stdout=subprocess.PIPE,
-                                        stdin=subprocess.PIPE)
-                data, err = proc.communicate()
-            else:
-                i, o = os.popen4(" ".join(args))
-                i.close()
-                data = o.read()
+            proc = subprocess.Popen(args,
+                                    stdout=subprocess.PIPE,
+                                    stdin=subprocess.PIPE)
+            data, err = proc.communicate()
         finally:
             if not self.options.keep_temporary_files:
                 os.remove(fname)
@@ -119,18 +103,14 @@
         try:
             if self.options.verbose:
                 print >> sys.stderr, "running:", " ".join(args)
-            if subprocess:
-                proc = subprocess.Popen(args,
-                                        stdout=subprocess.PIPE,
-                                        stderr=subprocess.PIPE,
-                                        stdin=subprocess.PIPE)
-                data, err = proc.communicate()
-                retcode = proc.wait()
-                if retcode:
-                    self.display_compiler_errors(err.splitlines())
-            else:
-                retcode = os.system(" ".join(args))
+            proc = subprocess.Popen(args,
+                                    stdout=subprocess.PIPE,
+                                    stderr=subprocess.PIPE,
+                                    stdin=subprocess.PIPE)
+            data, err = proc.communicate()
+            retcode = proc.wait()
             if retcode:
+                self.display_compiler_errors(err.splitlines())
                 raise CompilerError, "gccxml returned %s" % retcode
         finally:
             if not self.options.keep_temporary_files:
@@ -143,18 +123,27 @@
         import re, linecache
         pat = re.compile(r"(.*\.cpp):(\d+):(.*)")
         output = []
+        invalid_symbols = set()
         for line in lines:
             match = pat.search(line)
             if match:
                 fnm, lineno, errmsg = match.groups()
                 if re.match(r"\d+:", errmsg):
                     errmsg = errmsg.split(":", 1)[1]
-                text = "'%s' %s" % (linecache.getline(fnm, int(lineno)).rstrip(), errmsg)
+                src_line = linecache.getline(fnm, int(lineno)).rstrip()
+                is_define = re.match(r"^  DEFINE\((.*)\);$", src_line)
+                if is_define:
+                    invalid_symbols.add(is_define.group(1))
+                text = "'%s' %s" % (src_line, errmsg)
                 output.append(text)
             if line.startswith(" ") and output:
                 output[-1] = output[-1] + line.strip()
         for line in output:
             print >> sys.stderr, line
+        if invalid_symbols:
+            ofi = open("cparser.cfg", "a")
+            for sym in invalid_symbols:
+                ofi.write("%s\n" % sym)
 
     def get_defines(self, include_files):
         """'Compile' an include file with gccxml, and return a
@@ -254,7 +243,8 @@
                     typ = self.c_type_name(i.returns)
                 except TypeError, detail:
                     # XXX Warning?
-                    print >> sys.stderr,  "skipped #define %s %s" % (name, defines[name]), detail
+                    ## print >> sys.stderr,  "skipped #define %s %s" % (name, defines[name]), detail
+                    pass
                 else:
                     types[name] = typ
         return types
