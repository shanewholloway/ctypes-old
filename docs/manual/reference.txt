ctypes reference
================

loading shared libraries
------------------------

``LibraryLoader(dlltype)`` : classdesc
    Class which loads shared libraries.

``LoadLibrary(name, mode=RTLD_LOCAL, handle=None)`` : methoddesc
    Load a shared library.

``CDLL(name, mode=RTLD_LOCAL, handle=None)`` : classdesc
    XXX

``cdll`` : vardesc
    XXX

``OleDLL(name, mode=RTLD_LOCAL, handle=None)`` : funcdesc
    XXX

``oledll`` : vardesc
    XXX

``py_object`` : classdesc*
    XXX

``PyDLL(name, mode=RTLD_LOCAL, handle=None)`` : funcdesc
    XXX

``pydll`` : vardesc
    XXX

``RTLD_GLOBAL`` : vardesc
    XXX

``RTLD_LOCAL`` : vardesc
    XXX

``WinDLL(name, mode=RTLD_LOCAL, handle=None)`` : funcdesc
    XXX

``windll`` : vardesc
    XXX

``pythonapi()`` : vardesc
    XXX

foreign functions
-----------------

The ultimate goal of ``ctypes`` is to call functions in shared
libraries, aka as foreign functions.  Foreign function instances can
be created by accessing them as attributes of loaded shared libraries,
or by instantiating a *function prototype*.

Function prototypes are created by factory functions.

They are created by calling one of the following factory functions:

``CFUNCTYPE(restype, *argtypes)`` : funcdesc
    This is a factory function that returns a function prototype. The
    function prototype describes a function that has a result type of
    ``restype``, and accepts arguments as specified by
    ``argtypes``. The function prototype can be used to construct
    several kinds of functions, depending on how the prototype is
    called.

    The prototypes returned by ``CFUNCTYPE`` or ``PYFUNCTYPE`` create
    functions that use the standard C calling convention, prototypes
    returned from ``WINFUNCTYPE`` (on Windows) use the ``__stdcall``
    calling convention.

    Functions created by calling the ``CFUNCTYPE`` and ``WINFUNCTYPE``
    prototypes release the Python GIL before entering the foreign
    function, and acquire it back after leaving the function code.

``WINFUNCTYPE(restype, *argtypes)`` : funcdesc
    TBD

``PYFUNCTYPE(restype, *argtypes)`` : funcdesc
    TBD

``ArgumentError()`` : excdesc
    This exception is raised when a foreign function call cannot
    convert one of the passed arguments.



helper functions
----------------

``addressof(obj)`` : funcdesc
    Returns the address of the memory buffer as integer.  ``obj`` must
    be an instance of a ctypes type.

``alignment(obj_or_type)`` : funcdesc
    Returns the alignment requirements of a ctypes type.
    ``obj_or_type`` must be a ctypes type or instance.

``byref(obj)`` : funcdesc
    Returns a light-weight pointer to ``obj``, which must be an
    instance of a ctypes type. The returned object can only be used as
    a foreign function call parameter. It behaves similar to
    ``pointer(obj)``, but the construction is a lot faster.

``cast(obj, type)`` : funcdesc
    This function is similar to the cast operator in C. It returns a
    new instance of ``type`` which points to the same memory block as
    ``obj``. ``type`` must be a pointer type, and ``obj`` must be an
    object that can be interpreted as a pointer.

``create_string_buffer(init_or_size[, size])`` : funcdesc
    This function creates a mutable character buffer. The returned
    object is a ctypes array of ``c_char``.

    ``init_or_size`` must be an integer which specifies the size of
    the array, or a string which will be used to initialize the array
    items.

    If a string is specified as first argument, the buffer is made one
    item larger than the length of the string so that the last element
    in the array is a NUL termination character. An integer can be
    passed as second argument which allows to specify the size of the
    array if the length of the string should not be used.

    If the first parameter is a unicode string, it is converted into
    an 8-bit string according to ctypes conversion rules.

``create_unicode_buffer(init_or_size[, size])`` : funcdesc
    This function creates a mutable unicode character buffer. The
    returned object is a ctypes array of ``c_wchar``.

    ``init_or_size`` must be an integer which specifies the size of
    the array, or a unicode string which will be used to initialize
    the array items.

    If a unicode string is specified as first argument, the buffer is
    made one item larger than the length of the string so that the
    last element in the array is a NUL termination character. An
    integer can be passed as second argument which allows to specify
    the size of the array if the length of the string should not be
    used.

    If the first parameter is a 8-bit string, it is converted into an
    unicode string according to ctypes conversion rules.

``DllCanUnloadNow()`` : funcdesc
    Windows only: This function is a hook which allows to implement
    inprocess COM servers with ctypes. It is called from the
    DllCanUnloadNow function that the _ctypes extension dll exports.

``DllGetClassObject()`` : funcdesc
    Windows only: This function is a hook which allows to implement
    inprocess COM servers with ctypes. It is called from the
    DllGetClassObject function that the ``_ctypes`` extension dll exports.

``FormatError([code])`` : funcdesc
    Windows only: Returns a textual description of the error code. If
    no error code is specified, the last error code is used by calling
    the Windows api function GetLastError.

``GetLastError()`` : funcdesc
    Windows only: Returns the last error code set by Windows in the
    calling thread.

``memmove(dst, src, count)`` : funcdesc
    Same as the standard C memmove library function: copies ``count``
    bytes from ``src`` to ``dst``. ``dst`` and ``src`` must be
    integers or ctypes instances that can be converted to pointers.

``memset(dst, c, count)`` : funcdesc
    Same as the standard C memset library function: fills the memory
    block at address ``dst`` with ``count`` bytes of value
    ``c``. ``dst`` must be an integer specifying an address, or a
    ctypes instance.

``POINTER(type)`` : funcdesc
    This factory function creates and returns a new ctypes pointer
    type. Pointer types are cached an reused internally, so calling
    this function repeatedly is cheap. type must be a ctypes type.

``pointer(obj)`` : funcdesc
    This function creates a new pointer instance, pointing to
    ``obj``. The returned object is of the type POINTER(type(obj)).

    Note: If you just want to pass a pointer to an object to a foreign
    function call, you should use ``byref(obj)`` which is much faster.

``resize(obj, size)`` : funcdesc
    This function resizes the internal memory buffer of obj, which
    must be an instance of a ctypes type. It is not possible to make
    the buffer smaller than the native size of the objects type, as
    given by sizeof(type(obj)), but it is possible to enlarge the
    buffer.

``set_conversion_mode(encoding, errors)`` : funcdesc
    This function sets the rules that ctypes objects use when
    converting between 8-bit strings and unicode strings. encoding
    must be a string specifying an encoding, like ``'utf-8'`` or
    ``'mbcs'``, errors must be a string specifying the error handling
    on encoding/decoding errors. Examples of possible values are
    ``"strict"``, ``"replace"``, or ``"ignore"``.

    set_conversion_mode returns a 2-tuple containing the previous
    conversion rules. On windows, the initial conversion rules are
    ``('mbcs', 'ignore')``, on other systems ``('ascii', 'strict')``.

``sizeof(obj_or_type)`` : funcdesc
    Returns the size in bytes of a ctypes type or instance memory
    buffer. Does the same as the C ``sizeof()`` function.

``string_at(address[, size])`` : funcdesc
    This function returns the string starting at memory address
    address. If size is specified, it is used as size, otherwise the
    string is assumed to be zero-terminated.

``WinError(code=None, descr=None)`` : funcdesc
    Windows only: this function is probably the worst-named thing in
    ctypes. It creates an instance of WindowsError. If ``code`` is not
    specified, ``GetLastError`` is called to determine the error
    code. If ``descr`` is not spcified, ``FormatError`` is called to
    get a textual description of the error.

``wstring_at(address)`` : funcdesc
    This function returns the wide character string starting at memory
    address ``address`` as unicode string. If ``size`` is specified,
    it is used as the number of characters of the string, otherwise
    the string is assumed to be zero-terminated.


Data types
----------

``_CData`` : classdesc*
    This non-public class is the base class of all ctypes data types.
    Among other things, all ctypes type instances contain a memory
    block that hold C compatible data; the address of the memory block
    is returned by the ``addressof()`` helper function.  Another
    instance variable is exposed as ``_objects``; this contains other
    Python objects that need to be kept alive in case the memory block
    contains pointers.

Common methods of ctypes data types, these are all class methods (to
be exact, they are methods of the metaclass):

``from_address(address)`` : methoddesc
    This method returns a ctypes type instance using the memory
    specified by address.

``from_param(obj)`` : methoddesc
    This method adapts obj to a ctypes type. 

``in_dll(name, library)`` : methoddesc
    This method returns a ctypes type instance exported by a shared
    library. ``name`` is the name of the symbol that exports the data,
    ``library`` is the loaded shared library.

Common instance variables of ctypes data types:

``_b_base_`` : memberdesc
    Sometimes ctypes data instances do not own the memory block they
    contain, instead they share part of the memory block of a base
    object.  The ``_b_base_`` readonly member is the root ctypes
    object that owns the memory block.

``_b_needsfree_`` : memberdesc
    This readonly variable is true when the ctypes data instance has
    allocated the memory block itself, false otherwise.

``_objects`` : memberdesc
    This member is either ``None`` or a dictionary containing Python
    objects that need to be kept alive so that the memory block
    contents is kept valid.  This object is only exposed for
    debugging; never modify the contents of this dictionary.

Fundamental data types
----------------------

``_SimpleCData`` : classdesc*
    This non-public class is the base class of all fundamental ctypes
    data types. It is mentioned here because it contains the common
    attributes of the fundamental ctypes data types.  ``_SimpleCData``
    is a subclass of ``_CData``, so it inherits the methods and
    attributes of that.

Instances have a single attribute:

``value`` : memberdesc
    This attribute contains the actual value of the instance. For
    integer and pointer types, it is an integer, for character types,
    it is a single character string, for character pointer types it
    is a Python string or unicode string.

    When the ``value`` attribute is retrieved from a ctypes instance,
    usually a new object is returned each time.  ``ctypes`` does *not*
    implement original object return, always a new object is
    constructed.  The same is true for all other ctypes object
    instances.

Fundamental data types, whether returned as result of foreign function
calls, or, for example, by retrieving structure field members, are
transparently converted to native Python types.  In other words, if a
foreign function has a ``restype`` of ``c_char_p``, you will always
receive a Python string, *not* a ``c_char_p`` instance.

Subclasses of fundamental data types do *not* inherit this behaviour.
So, if a foreign functions ``restype`` is a subclass of ``c_void_p``,
you will receive an instance of this subclass from the function call.
Of course, you can get the value of the pointer by accessing the
``value`` attribute.

These are the fundamental ctypes data types:

``c_byte`` : classdesc*
    Represents the C signed char datatype, and interprets the value as
    small integer. The constructor accepts an optional integer
    initializer; no overflow checking is done.

``c_char`` : classdesc*
    Represents the C char datatype, and interprets the value as a single
    character. The constructor accepts an optional string initializer,
    the length of the string must be exactly one character.

``c_char_p`` : classdesc*
    Represents the C char * datatype, which must be a pointer to a
    zero-terminated string. The constructor accepts an integer
    address, or a string.

``c_double`` : classdesc*
    Represents the C double datatype. The constructor accepts an
    optional float initializer.

``c_float`` : classdesc*
    Represents the C double datatype. The constructor accepts an
    optional float initializer.

``c_int`` : classdesc*
    Represents the C signed int datatype. The constructor accepts an
    optional integer initializer; no overflow checking is done. On
    platforms where ``sizeof(int) == sizeof(long)`` it is an alias to
    ``c_long``.

``c_int8`` : classdesc*
    Represents the C 8-bit ``signed int`` datatype. Usually an alias for
    ``c_byte``.

``c_int16`` : classdesc*
    Represents the C 16-bit signed int datatype. Usually an alias for
    ``c_short``.

``c_int32`` : classdesc*
    Represents the C 32-bit signed int datatype. Usually an alias for
    ``c_int``.

``c_int64`` : classdesc*
    Represents the C 64-bit ``signed int`` datatype. Usually an alias
    for ``c_longlong``.

``c_long`` : classdesc*
    Represents the C ``signed long`` datatype. The constructor accepts an
    optional integer initializer; no overflow checking is done.

``c_longlong`` : classdesc*
    Represents the C ``signed long long`` datatype. The constructor accepts
    an optional integer initializer; no overflow checking is done.

``c_short`` : classdesc*
    Represents the C ``signed short`` datatype. The constructor accepts an
    optional integer initializer; no overflow checking is done.

``c_size_t`` : classdesc*
    Represents the C ``size_t`` datatype.

``c_ubyte`` : classdesc*
    Represents the C ``unsigned char`` datatype, it interprets the
    value as small integer. The constructor accepts an optional
    integer initializer; no overflow checking is done.

``c_uint`` : classdesc*
    Represents the C ``unsigned int`` datatype. The constructor accepts an
    optional integer initializer; no overflow checking is done. On
    platforms where ``sizeof(int) == sizeof(long)`` it is an alias for
    ``c_ulong``.

``c_uint8`` : classdesc*
    Represents the C 8-bit unsigned int datatype. Usually an alias for
    ``c_ubyte``.

``c_uint16`` : classdesc*
    Represents the C 16-bit unsigned int datatype. Usually an alias for
    ``c_ushort``.

``c_uint32`` : classdesc*
    Represents the C 32-bit unsigned int datatype. Usually an alias for
    ``c_uint``.

``c_uint64`` : classdesc*
    Represents the C 64-bit unsigned int datatype. Usually an alias for
    ``c_ulonglong``.

``c_ulong`` : classdesc*
    Represents the C ``unsigned long`` datatype. The constructor accepts an
    optional integer initializer; no overflow checking is done.

``c_ulonglong`` : classdesc*
    Represents the C ``unsigned long long`` datatype. The constructor
    accepts an optional integer initializer; no overflow checking is
    done.

``c_ushort`` : classdesc*
    Represents the C ``unsigned short`` datatype. The constructor accepts an
    optional integer initializer; no overflow checking is done.

``c_void_p`` : classdesc*
    Represents the C ``void *`` type. The value is represented as
    integer. The constructor accepts an optional integer initializer.

``c_wchar`` : classdesc*
    Represents the C ``wchar_t`` datatype, and interprets the value as a
    single character unicode string. The constructor accepts an
    optional string initializer, the length of the string must be
    exactly one character.

``c_wchar_p`` : classdesc*
    Represents the C ``wchar_t *`` datatype, which must be a pointer to
    a zero-terminated wide character string. The constructor accepts
    an integer address, or a string.

``HRESULT`` : classdesc*
    Windows only: Represents a ``HRESULT`` value, which contains success
    or error information for a function or method call.

structured data types
---------------------

``Union(*args, **kw)`` : classdesc
    Abstract base class for unions in native byte order.

``BigEndianStructure(*args, **kw)`` : classdesc
    Abstract base class for structures in big endian byte order.

``LittleEndianStructure(*args, **kw)`` : classdesc
    Abstract base class for structures in little endian byte order.

``Structure(*args, **kw)`` : classdesc
    Abstract base class for structures in native byte order.

Concrete structure and union types must be created by subclassing one
of these types, and at least define a ``_fields_`` class variable.
``ctypes`` will create descriptors which allow reading and writing the
fields by direct attribute accesses.

Structures with non-native byte order cannot contain pointer type
fields, or any other data types containing pointer type fields.

``_fields_`` : memberdesc
    A sequence defining the structure fields.  The items must be
    2-tuples or 3-tuples.  The first item is the name of the field,
    the second item specifies the type of the field; it can be any
    ctypes data type.

    The third item is optional, and only allowed for integer field
    types.  It allows to define structures containing bit fields, it
    must be a small positive integer specifying the width of the bit
    field.

    Field names must be unique within one structure or union.  This is
    not checked.

    It is possible to define the ``_fields_`` class variable *after*
    the class statement that defines the Structure subclass, this
    allows to create data types that directly or indirectly reference
    themselves::

        class List(Structure):
	    pass
	List._fields_ = [("pnext", POINTER(List)),
                         ...
			]

    The ``_fields_`` class variable must, however, be defined before
    the type is first used (an instance is created, ``sizeof()`` is
    called on it, and so on).  Later assignments to the ``_fields_``
    class variable will raise an AttributeError.

    Structure and union subclass constructors accept both

``_pack_`` : memberdesc
    An optional small integer that allows to override the alignment of
    structure fields in the instance.  ``_pack_`` must be defined when
    ``_fields_`` is assigned, otherwise it will have no effect.

``_anonymous_`` : memberdesc
    An optional sequence that lists the names of unnamed (anonymous)
    fields.

    The fields listed in this variable must be structure or union type
    fields.  ``ctypes`` will create descriptors in the structure type
    that allows to access the nested fields directly, without the need
    to create the structure or union field.

    Here is an example type (Windows)::

        class _U(Union):
            _fields_ = [("lptdesc", POINTER(TYPEDESC)),
                        ("lpadesc", POINTER(ARRAYDESC)),
			("hreftype", HREFTYPE)]

        class TYPEDESC(Structure):
            _fields_ = [("u", _U),
                        ("vt", VARTYPE)]

            _anonymous_ = ("u",)

    The ``TYPEDESC`` structure describes a COM data type, the ``vt``
    field specifies which one of the union fields is valid.  Since the
    ``u`` field is defined as anonymous field, it is now possible to
    access the members directly off the TYPEDESC instance.
    ``td.lptdesc`` and ``td.u.lptdesc`` are equivalent, but the former
    is faster since it does not need to create a temporary ``_U``
    instance::

        td = TYPEDESC()
        td.vt = VT_PTR
	td.lptdesc = POINTER(some_type)
	td.u.lptdesc = POINTER(some_type)
