ctypes reference

  "overview":index.html :: "tutorial":tutorial.html ::
  reference :: "faq":faq.html

  ( Work in progress: "COM":com.html :: "COM sample":sum_sample.html )

  Note

    This reference is probably not worth it's name, so incomplete it is.

  Loading shared libraries

    ctypes defines some library loader objects which can load shared
    libraries. Functions accessed as attributes of shared library
    objects will be called with different calling conventions,
    depending on the Loader which returned the library object. (FIXME:
    add a section about C function objects and how to set the calling
    convention)

    'cdll' -- Loader for shared libraries using the standard C calling
    convention of the OS platform (known as cdecl in Windows).

    'windll' (Windows only) -- For libraries using the stdcall calling
    conventions (all Windows system libraries).
        
    'oledll' (Windows only) -- Like 'windll', additionaly assumes the
    functions return a Windows 'HRESULT' error code. The error code is
    used to automatically raise 'WindowsError' Python exceptions when
    the function call fails.

    Methods of loader objects:

        'LoadLibrary(libname)' -- Loads the library given by
        libname. On most systems libname is the filename of the
        shared library; when it's not a path name it will be searched
        in a system dependent list of locations (on many systems
        additional search paths can be specified by an environment
        variable). Sometimes extensions like .dll on Windows can be
        omitted.

        'LoadLibraryVersion(name, version)' -- Builds a (system
        depend) filename from the library name and version and loads
        it. 'name' is the library name without prefix like lib,
        suffixes like .so, .dylib or version number (this form is used
        for the posix linker option -l). 'version' is the major
        version number (for platforms which code this into the
        filename). This should be used if a library is available on
        different platforms (using the particular naming convention of
        each platform).

        'find(name)' -- Tries to find a library and loads it. 'name'
        is the library name (as in LoadLibraryVersion above). After
        loading, the filename of the loaded library is printed on
        stdout. This function might call other programs like the
        compiler to find the library. When you use ctypes to write a
        shared library wrapping, consider using LoadLibraryVersion
        instead (or LoadLibrary, if the library is platform specific).

        Library loading is also implemented as attribute access of the
        loader objects. LoadLibrary is called with the attribute name,
        and the returned dll object is cached as attribute value.
        Additionaly, key lookup can be used, so cdll.libname is the
        same as cdll['libname']. Library names beginning with an
        underscore (_) can't be accessed as attributes of a loader
        object (use LoadLibrary).

    Shared libraries are accessed when compiling/linking a program,
    and when the program is run. The purpose of the find method is to
    locate a library similar to what the compiler does (on platforms
    with several versions of a shared library the most recent should
    be loaded), while LoadLibrary acts like when a program is run, and
    uses the runtime loader directly. LoadLibraryVersion works like
    LoadLibrary but tries to be platform independent (for cases where
    this makes sense). Loading via attribute access is a shorthand
    notation especially usefull for interactive use.

  Common operations on ctypes instances

    'sizeof(obj) -> integer'

        Return an integer specifying the number of bytes in the memory
        block.  This corresponds to the C code 'sizeof(obj)'.  Does
        also work for types.

    'byref(obj) -> cparam-object'

        Similar to '&obj' in C code, but only usable for passing the
        object as a parameter to a C function call.

    'pointer(obj) -> ctypes instance'

        Same as '&obj' in C.  Different from 'byref(obj)', this
        creates a new ctypes object, acting as a pointer to 'obj'.  It
        will be an instance of a pointer class pointing to 'type(obj)'
        instances.  The pointer class is created on the fly, if it
        does not yet exist.

    'addressof(obj) -> integer'

        Same as '(int)&obj' in C.  Returns the address of the internal
        memory buffer as an integer.


  Common operation on ctypes types

    ctypes types/classes extensively use the new Python type system, so
    the following may first look unusual to the Pyhon programmer.

    'POINTER(ctype) -> class'

        Return a subclass of 'ctype'. Instances of this class are
        pointers to 'ctype'.  The subclass will be created if it does
        not yet exist, otherwise it is returned from a builtin cache.

    'ctype * num -> array class'

        Multiplying a 'ctype' class with a positive integer creates a
        subclass of 'Array'. Instances are arrays holding 'num'
        instances of 'ctype'.

    'ctype.from_address(address) -> ctypes instance'

        Create a new instance of 'ctype' from the memory block at the
        integer 'address'. It must no longer be accessed if the memory
        block becomes invalid, the programmer must ensure this.


  ctypes instance methods/properties

    'obj._as_parameter_ -> magic'

        Automatically called when a ctype object is used as a
        parameter in a C function call *by value*.  Must *return*
        something that can be understood by the C function call
        parameter converter.  Currently, it either returns an integer,
        a string or a unicode string. These are passed as the
        corresponding C data type to the function call.
