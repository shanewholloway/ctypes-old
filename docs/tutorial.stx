ctypes tutorial

  "ctypes home":../ctypes.html :: tutorial :: "reference":reference.html :: "faq":faq.html

  This tutorial describes version 0.6 of 'ctypes'. There have been
  quite some changes to previous versions, the most important are
  listed "here":changes.html.

  Loading dynamic link libraries

    'ctypes' exports the 'cdll', and on Windows also 'windll'
    and 'oledll' objects to load dynamic link libraries.

    You can load libraries by accessing them as attributes of these
    objects.  'cdll' loads libraries which export functions using the
    standard 'cdecl' calling convention, while 'windll' libraries call
    functions using the 'stdcall' calling convention. 'oledll' also
    uses the 'stdcall' calling convention, and assumes the functions
    return a Windows 'HRESULT' error code. The error code is used to
    automatically raise 'WindowsError' Python exceptions when the
    function call fails.

    Here are some examples::

      >>> from ctypes import windll, cdll
      >>> print windll.kernel32
      <WinDLL 'kernel32', handle 77e80000 at 7ecfe8>
      >>> print cdll.msvcrt
      <CDLL 'msvcrt', handle 78000000 at 80b010>

    XXX Libs not on default search path, libc.so.1 on Linux?

  Accessing functions from loaded dlls

    Functions are accessed as attributes of dll objects::

      >>> from ctypes import windll, cdll
      >>> print cdll.msvcrt.printf
      <ctypes._CdeclFuncPtr object ar 0x00905F68>
      >>> print windll.kernel32.GetModuleHandleA
      <ctypes._StdcallFuncPtr object ar 0x008E6D28>
      >>> print windll.kernel32.MyOwnFunction
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
        File "ctypes.py", line 239, in __getattr__
          func = _StdcallFuncPtr(name, self)
      ValueError: function 'MyOwnFunction' not found

    Note that win32 system dlls like 'kernel32', 'user32', and others,
    sometimes export ANSI as well as UNICODE versions of
    functions. The UNICODE version is exported with an 'W' appended to
    the name, while the ANSI version is exported with an 'A' appended
    to the name. The win32 'GetModuleHandle' function, which returns a
    *module handle* for a given module name, has these C prototypes,
    and a C macro is used to expose one of them as GetModuleHandle
    depending on whether UNICODE is defined or not::

      /* ANSI version */
      HMODULE GetModuleHandleA(LPCSTR lpModuleName);
      /* UNICODE version */
      HMODULE GetModuleHandleW(LPCWSTR lpModuleName);

    'windll' does not try to select on of them automatically, you must
    load the version you need by specifying 'GetModuleHandleA' or
    'GetModuleHandleW' explicitely, and call them with normal strings
    or unicode strings respectively.

    Sometimes, dlls export functions with names which aren't valid
    Python identifiers, like '"??2@YAPAXI@Z"'. In this case you have
    to use 'getattr' to retrieve the function XXX Better example::

      >>> getattr(cdll.msvcrt, "??2@YAPAXI@Z")
      <ctypes._CdeclFuncPtr object at 0x00905EE0>
      >>>


  Calling functions

    You can call these functions like any other Python callable. This
    example uses the 'time()' function, which returns system time in
    seconds since the UNIX epoch, and the 'GetModuleHandleA()'
    function, which returns a win32 module handle.

    This example calls both functions with a NULL pointer ('None'
    should be used as the NULL pointer)::

      >>> from ctypes import cdll, windll
      >>> print cdll.msvcrt.time(None)
      1048777320
      >>> print hex(windll.kernel32.GetModuleHandleA(None))
      0x1d000000

    'ctypes' tries at its best to protect you from calling functions
    with the wrong number of arguments.  Unfortunately this only works
    on Windows. It does this by examining the stack after the function
    returns::

      >>> windll.kernel32.GetModuleHandleA()
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Procedure probably called with not enough arguments
      >>> windll.kernel32.GetModuleHandleA(0, 0)
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Procedure probably called with too many arguments
      >>>

    On Windows, 'ctypes' uses win32 structured exception handling to
    prevent crashes from general protection faults when functions are
    called with invalid argument values::

      >>> windll.kernel32.GetModuleHandleA(32)
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      WindowsError: exception: access violation
      >>>

    There are, however, enough ways to crash Python with 'ctypes',
    so you should be careful aywany.

    Python integers, strings and unicode strings are the only objects
    that can directly be used as parameters in these function calls.

    Before we move on calling functions with other parameter types, we
    have to learn more about 'ctypes' data types.

  Simple data types

    'ctypes' defines a number of primitive C compatible data types :

    |---------------------------------------------|
    |ctypes' type |C type             |Python type|
    |=============================================|
    |'c_char'     |'char'             |character  |
    |---------------------------------------------|
    |'c_byte'     |'char'             |integer    |
    |---------------------------------------------|
    |'c_ubyte'    |'unsigned char'    |integer    |
    |---------------------------------------------|
    |'c_short'    |'short'            |integer    |
    |---------------------------------------------|
    |'c_ushort'   |'unsigned short'   |integer    |
    |---------------------------------------------|
    |'c_int'      |'int'              |integer    |
    |---------------------------------------------|
    |'c_uint'     |'unsigned int'     |integer    |
    |---------------------------------------------|
    |'c_long'     |'long'             |integer    |
    |---------------------------------------------|
    |'c_ulong'    |'unsigned long'    |long       |
    |---------------------------------------------|
    |'c_longlong' |'__int64' or       |long       |
    |        	  |'long long'        |           |
    |---------------------------------------------|
    |'c_ulonglong'|'unsigned __int64' or|long     |
    |        	  |'unsigned long long'|          |
    |---------------------------------------------|
    |'c_char_p'	  |'char *'           |string     |
    |        	  |(NUL terminated)   |           |
    |---------------------------------------------|
    |'c_wchar_p'  |'wchar_t *'        |unicode    |
    |        	  |(NUL terminated)   |           |
    |---------------------------------------------|
    |'c_void_p'	  |'void *'           |integer    |
    |---------------------------------------------|

    All these types can be created by calling them with an optional
    initializer of the correct type and value::

      >>> c_int()
      c_int(0)
      >>> c_char_p("Hello World")
      c_char_p('Hello, World')
      >>> c_uint(-3)
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Value out of range
    
    Since these types are mutable, their value can also be changed afterwards::

      >>> i = c_int(42)
      >>> print i
      c_int(42)
      >>> print i.value
      42
      >>> i.value = -99
      >>> print i.value
      -99

    Assigning a new value to instances of the pointer types
    'c_char_p', 'c_wchar_p', and 'c_void_p' change the *memory
    location* they point to, *not the contents* of the memory block
    (of course not, because Python strings are immutable)::

      >>> s = "Hello, World"
      >>> c_s = c_char_p(s)
      >>> print c_s
      c_char_p('Hello, World')
      >>> c_s.value = "Hi, there"
      >>> print c_s
      c_char_p('Hi, there')
      >>> print s                 # first string is unchanged
      Hello, World      

    You should be careful, however, not to pass them to functions
    expecting pointers to mutable memory. If you need mutable memory
    blocks, ctypes has a 'c_buffer' function which creates these in
    various ways.  The current memory block contents can be accessed
    (or changed) with the 'raw' property, if you want to access it as
    NUL terminated string, use the 'string' property::

      >>> from ctypes import c_buffer, sizeof
      >>> p = c_buffer(3)      # create a 3 byte buffer, initialized to NUL bytes
      >>> print sizeof(p), repr(p.raw)
      3 '\x00\x00\x00'
      >>> p = c_buffer("Hello")      # create a buffer containing a NUL terminated string
      >>> print sizeof(p), repr(p.raw)
      6 'Hello\x00'
      >>> print repr(p.value)
      'Hello'
      >>> p = c_buffer("Hello", 10)  # create a 10 byte buffer
      >>> print sizeof(p), repr(p.raw)
      10 'Hello\x00\x00\x00\x00\x00'
      >>> p.value = "Hi"      
      >>> print sizeof(p), repr(p.raw)
      10 'Hi\x00lo\x00\x00\x00\x00\x00'
      >>>

    **XXX MARKER**

  Calling functions, continued

    Note that printf prints to the real standard output channel, *not*
    to 'sys.stdout', so these examples will only work at the console
    prompt, not from within *IDLE* or *PythonWin*::

      >>> from ctypes import cdll; printf = cdll.msvcrt.printf
      >>> printf("Hello, %s\n", "World!")
      Hello, World!
      14
      >>> printf("Hello, %S", u"World!") # Note the upper case S!
      Hello, World!
      14
      >>> printf("%d bottles of beer\n", 42)
      42 bottles of beer
      19
      >>> printf("%f bottles of beer\n", 42.5)
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      TypeError: Don't know how to convert parameter 2
      >>>

    Python floats have to be wrapped in 'c_float()' or
    'c_double()' calls, so that they can be passed as the
    required C data type::

      >>> from ctypes import cdll, c_double
      >>> printf = cdll.msvcrt.printf
      >>> printf("An int %d, a double %f\n", 1234, c_double(3.14))
      Integer 1234, double 3.1400001049
      34
      >>>

  <!--
  Calling functions with your own custom data types

    XXX explain the required _as_parameter_ property
  -->

  Specifying required argument types (function prototypes)

    It is possible to specify the required argument types of functions
    exported from DLLs by assigning the 'argtypes' attribute.  This
    must be set to a list of C data types ('printf' is probably not a
    good example here, because it takes a variable number and
    different types of parameters depending on the format string, on
    the other hand this is quite handy to experiment with this
    feature)::

      >>> from ctypes import cdll, c_int, c_char_p, c_double
      >>> printf = cdll.msvcrt.printf
      >>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]
      >>> printf("String '%s', Int %d, Double %f\n", "Hi", 10, 2.2)
      String 'Hi', Int 10, Double 2.200000

    Specifying a format protects against incompatible argument types
    (just as a prototype for a C function), and tries to convert the
    arguments to valid types::

      >>> printf("%d %d %d", 1, 2, 3)
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      TypeError: string expected instead of int instance
      >>> printf("%s %d %f", "X", 2, 3)
      X 2 3.00000012
      >>>

    This also works with other data types (including user defined
    types like structures, unions, arrays, or pointers).

  <!--
  Placeholder
  Using your own types

    XXX explain the from_param class method

  -->


  Return types

    By default functions are assumed to return integers.  Different
    return types can be specified by setting the 'restype' attribute of
    the function object.

    Allowed values for 'restype' are simple data types like 'c_int',
    'c_long', 'c_char' and so on as well as pointers to other data
    types. Functions returning structures are not yet supported.
    
    In this example 'c_char_p' is the ctypes equivalent of 'char *' in
    C::

      >>> from ctypes import c_char_p, byref, cdll
      >>> strchr = cdll.msvcrt.strchr
      >>> strchr("abcdef", ord("d"))
      8059983
      >>> strchr.restype = c_char_p # c_char_p is a pointer to a string
      >>> strchr("abcdef", ord("d"))
      'def'
      >>> print strchr("abcdef", ord("x"))
      None
      >>>

    If you want to avoid the 'ord("x")' calls above, you can also use
    the 'c_char' datatype::

      >>> from ctypes import c_char, c_char_p, byref, cdll
      >>> msvcrt = cdll.msvcrt
      >>> msvcrt.strchr.restype = "s"
      >>> msvcrt.strchr.argtypes = [c_char_p, c_char]
      >>> msvcrt.strchr("abcdef", "d")
      'def'
      >>> msvcrt.strchr("abcdef", "def")
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      TypeError: one character string expected
      >>> print msvcrt.strchr("abcdef", "x")
      None
      >>>

    You can use a callable Python object (a function or a class for
    example) as the 'restype' attribute.  This callable will be called
    with the 'integer* the C function returns, and the result of this
    call will be used as the result of the function call. This is
    useful to check for error return values and automatically raise an
    exception::

      >>> from ctypes import windll, WinError
      >>> GetModuleHandle = windll.kernel32.GetModuleHandleA
      >>> def ValidHandle(value):
      ...     if value == 0:
      ...         raise WinError()
      ...     return value
      ...
      >>>
      >>> GetModuleHandle.restype = ValidHandle
      >>> GetModuleHandle(None)
      486539264
      >>> GetModuleHandle("something silly")
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
	File "<stdin>", line 3, in ValidHandle
      WindowsError: [Errno 126] The specified module could not be found.
      >>>

    'WinError' is a function which will call Windows' FormatMessage
    api to get the string representation of an error code, and returns
    an exception.  'WinError' takes an optional error code parameter,
    if none is used, it calls 'GetLastError' to retrieve it.


  Passing parameters by reference

    Sometimes a C api function expects a *pointer* to simple data type
    as parameter, and maybe the C function writes into the
    corresponding location. This is also known as *passing parameters
    by reference*.

    'ctypes' exports the 'byref' function which is used to pass
    parameters by reference.  The same effect can be achieved with the
    'pointer' function, although 'pointer' does a lot more work since
    it constructs a real pointer object, so it is probably better to
    use 'byref' if you don't need the pointer object itself::

      >>> from ctypes import c_int, c_float, c_string, byref, cdll
      >>> msvcrt = cdll("msvcrt")
      >>> i = c_int()
      >>> f = c_float()
      >>> s = c_string('\000' * 32)
      >>> print i.value, f.value, repr(s.value)
      0 0.0 ''      
      >>> msvcrt.sscanf("1 3.14 Hello", "%d %f %s",
      ...               byref(i), byref(f), s)
      3
      >>> print i.value, f.value, repr(s.value)
      1 3.1400001049 'Hello'

  COM

    XXX Move somewhere else

    to be written. In short: You *can* call methods on COM objects,
    you can even *implement* and expose COM objects.

    For now, see the 'test' directory of the source distribution for
    examples.



  Structures and Unions

    Structures and unions must derive from the 'Structure' and 'Union'
    base classes which are defined in the 'ctypes' module. Each
    subclass must define a '_fields_' attribute.  '_fields_' must be a
    list of *2-tuples*, containing a *field name* and a *field type*.

    The field type must be a 'ctypes' type like 'c_int', or another
    derived 'ctypes' type: structure, union, array, pointer.

    Here is a simple example of a POINT structure, which contains two
    integers named 'x' and 'y' ::

      >>> from ctypes import Structure
      >>> class POINT(Structure):
      ...     _fields_ = [("x", c_int),
      ...                 ("y", c_int)]
      ...
      >>> point = POINT(10, 20)
      >>> print point.x, point.y
      10 20
      >>>

    You can, however, build much more complicated
    structures. Structures can itself contain other structures by
    using a structure as a field type.

    Here is a RECT structure which contains two POINTs named
    'upperleft' and 'lowerright' ::

      >>> class RECT(Structure):
      ...     _fields_ = [("upperleft", POINT),
      ...                 ("lowerright", POINT)]
      ...
      >>> rc = RECT(point)
      >>> print rc.upperleft.x, rc.upperleft.y
      10 20
      >>> print rc.lowerright.x, rc.lowerright.y
      0 0
      >>>

    Fields descriptors can be retrieved from the class, they have
    readonly 'size' and 'offset' attributes describing the size in
    bytes and the offset of this field from the beginning of the
    internal memory buffer:

      >>> print POINT.x.size, POINT.x.offset
      0 4
      >>> print POINT.y.size, POINT.y.offset
      4 4
      >>>

  Arrays

    Arrays are sequences, containing a fixed number of instances of
    the same type.

    The recommended way to create array types is by multiplying a data
    type with a positive integer::

      TenPointsArray = POINT * 10

    Here is an example of an somewhat artifical data type, a structure
    containing 4 POINTs among other stuff::

      >>> from ctypes import Structure
      >>> class POINT(Structure):
      ...    _fields_ = ("x", "i"), ("y", "i")
      ...
      >>> class MyStruct(Structure):
      ...    _fields_ = [("a", "i"),
      ...	         ("b", "f"),
      ...                ("point_array", POINT * 4)]
      >>>
      >>> print len(MyStruct().point_array)
      4


    Instances are created in the usual way, by calling the class::

      arr = TenPointsArray()
      for pt in arr:
          print pt.x, pt.y

    The above code print a series of '0 0' lines, because the array
    contents is initialized to zeros.

    Initializers of the correct type can also be specified::

      >>> from ctypes import c_int
      >>> TenIntegers = c_int * 10
      >>> ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
      <__main__.c_int_Array_10 object at 0x009119F0>
      >>> for i in ii: print i,

      XXX doesn't work currently

  Pointers

    Pointer instances are created by calling the 'pointer' function
    on a ctypes' type::

    >>> from ctypes import c_int, pointer
    >>> i = c_int(42)
    >>> pi = pointer(i)

    Pointer instances have a 'contents' attribute which returns the
    ctypes' type pointed to.

    Pointer instances 

    Note: This section is out of date and needs to be rewritten. In
    the meantime refer to the samples in the source distribution for
    examples.

    Pointers are created by subclassing 'ctypes._Pointer', supplying a
    '_type_' class attribute. '_type_' must be a 'Structure' subclass::

      from ctypes import _Pointer
      class LPINT(_Pointer):
          _type_ = c_int

      lpint = LPINT()
      lpint.contents = c_int(42)

    '_Pointer' instances have a 'contents' attribute, which contains the
    pointed at value, and can be read and written::

      print lpint.contents.value

      lpint.contents.value = c_int(3)
      lpint.contents.value = "abc" # raises TypeError

    A more convenient way to create Pointers is the 'Pointer'
    function.  Calling 'Pointer' with a *class* returns a '_Pointer'
    subclass, calling 'Pointer' with an *instance* returns an instance
    of the pointer class pointing to the passed value. If you call
    'Pointer'with an instance, a new class is created on the fly::

      >>> from ctypes import Pointer, c_int
      >>> LPINT = Pointer(c_int)
      >>> print LPINT
      <class 'ctypes.LP_c_int'>
      >>> pi = LPINT(c_int(42))
      >>> print pi
      <ctypes.LP_c_int object at 0x...>
      >>> pi2 = Pointer(c_int(22))
      >>> print pi2
      <ctypes.LP_c_int object at 0x...>
      >>> print pi2.__class__
      <class 'ctypes.LP_c_int'>

    Note that calling Pointer with a class *instance* creates a new
    pointer *class* on the fly, and returns an instance of this class.

  Structures and Unions (again)

    The shorthand notation for creating Pointer and Array subclasses
    is very convenient in combination with Structures containing
    Pointers or Arrays.

    blahg blah

  Incomplete Types

    *Incomplete Types* are structures, unions or arrays whose members
    are not yet specified. In the 'ctypes' context, you can create
    Pointers to these types by passing their name (as a string) to the
    Pointer function, and complete the _Pointer subclass later.

    Consider this example (C-code)::

      struct cell;

      struct {
          int value;
          struct cell *next;
      } cell;

    The straightforward translation into Python would be::

      class cell(Structure):
          _fields_ = [("value", "i"),
	              ("next", Pointer(cell))]

    Unfortunately this will not work - it raises a name error::

      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
        File "<stdin>", line 2, in cell
      NameError: name 'cell' is not defined

    because 'class cell' is not available in the class statement itself.

    We can do it by creating an *incomplete _Pointer subclass* by
    calling Pointer with the class _name_, and later setting the
    complete type of the _Pointer subclass 'lpcell' ::

      from ctypes import Structure, Pointer, SetPointerType
      lpcell = POINTER("cell")

      class cell(Structure):
          _fields_ = [("value", "i"),
                      ("next", lpcell)]

      SetPointerType(lpcell, cell)

  Callback functions

    Sometimes, functions expect a function pointer (callback function)
    as an argument.

    'ctypes' has a 'CFunction' base type, which is used to define and
    create function pointers from Python callable objects.

    Subclasses must provide a '_types_' attribute, which is a string
    containing format specifiers (only 'i' for 'int' and 's' for 'char
    *' are currently allowed) for the arguments the function expects
    and a '_stdcall_' attribute, which must be '1' to specify the
    '__stdcall' calling convention, or '0' to specify '__cdecl'
    calling convention.

    Instances of function pointers are created by calling the
    (sub)class with a *Python callable* as argument. This callable
    must return None (which will be interpreted as '0'), or an
    integer.
    
    We are now trying to create a C callable function ('callback')
    which we can pass to the standard C library 'qsort' function.
    'qsort' expects

    The following example creates a C callable function ('callback')
    usable by the 'qsort' standard library function::

      class CMPFUNC(CFunction):
          _types_ = 'ii'
	  _stdcall_ = 1

      def compare(adr1, adr2):
          return cmp(adr1, adr2)

      cmpfunc = CMPFUNC(compare)

    Note that the same effect could be achived by this code::

      class CMPFUNC(CFunction):
          _types_ = 'ii'
	  _stdcall_ = 0

      cmpfunc = CMPFUNC(cmp)

    'cmpfunc' will now be a *pointer* to a C callable function with
    this signature::

      int __cdecl cmpfunc(int, int);

    Beware: If you use the 'qsort' standard library function to sort
    an array of integers, the 'compare' function will receive
    *pointers* into the array, not the array items itself, so the
    above code will *not* work with qsort.

    To remedy, we must expect *pointers* in the compare function, and
    retrieve the actual contents, and compare those.

    This code implements a function doing this::

      from ctypes import CFunction, c_int

      class CMPFUNC(CFunction):
          _types_ = "ii"
	  _stdcall_ = 0

      def compare(a1, a2):
          v1 = c_int.from_address(a1).value
	  v2 = c_int.from_address(a2).value
	  return cmp(v1, v2)

      cmpfunc = CMPFUNC(compare)

    Assuming 'ia10' is an array in 10 integers, and '4' is sizeof(int),
    we can sort the array contents in this way::

       msvcrt.qsort(ia, len(ia), 4, compare)

  Surprises

    There are some corners in 'ctypes' where you may be expect
    something else than what actually happens.

    Consider the following example::

      >>> from ctypes import Structure
      >>> class POINT(Structure):
      ...     _fields_ = ("x", "i"), ("y", "i")
      ...
      >>> class RECT(Structure):
      ...     _fields_ = ("a", POINT), ("b", POINT)
      ...
      >>> p1 = POINT(1, 2)
      >>> p2 = POINT(3, 4)
      >>> rc = RECT(p1, p2)
      >>> print rc.a.x, rc.a.y, rc.b.x, rc.b.y
      1 2 3 4
      >>> # now swap the two points
      >>> rc.a, rc.b = rc.b, rc.a
      >>> print rc.a.x, rc.a.y, rc.b.x, rc.b.y
      3 4 3 4

    Hm. We certainly expected the last statement to print '3 4 1 2'.
    What happended? Here are the steps of the 'rc.a, rc.b = rc.b,
    rc.a' line above::

      >>> temp0, temp1 = rc.b, rc.a
      >>> rc.a = temp0
      >>> rc.b = temp1

    Note that 'temp0' and 'temp1' are objects still using the internal
    buffer of the 'rc' object above. So executing 'rc.a = temp0'
    copies the buffer contents of 'temp0' into 'rc' 's buffer.  This, in turn,
    changes the contents of 'temp1'. So, the last assignment 'rc.b = temp1',
    doesn't have the expected effect.

    Keep in mind that retrieving subobjects from Structure, Unions,
    and Arrays doesn't *copy* the subobject, it does more retrieve a
    wrapper object accessing the root-object's underlying buffer.


  Bugs, ToDo and non-implemented things

    Bitfields are not implemented. This probably counts as bug.

    Enumeration types are not implemented. I do not consider this as a
    bug - they can be implemented as well in pure python (maybe as
    'int' subclasses).

    What about 'long double'? They exist in MSVC for example, and have
    80 bits.

    The whole unicode / wchar stuff is not yet implemented - although
    it is mentioned above.

    C function pointers returning something else than integers (or
    void) cannot be constructed. Actually they can return anything
    which has sizeof(x) == sizeof(int).

<!--
  Local Variables:
  compile-command: "make_html"
  End:
-->
